<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>CppWAMP: Registrations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CppWAMP
   </div>
   <div id="projectbrief">C++11 client library for the WAMP protocol</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_registrations.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Registrations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#CallSlots">Call Slots</a></li>
<li class="level1"><a href="#BasicCallSlots">Basic Call Slots</a></li>
<li class="level1"><a href="#BasicCoroutineCallSlots">Basic Coroutine Call Slots</a></li>
<li class="level1"><a href="#UnpackedCallSlots">Unpacked Call Slots</a></li>
<li class="level1"><a href="#UnpackedCoroutineCallSlots">Unpacked Coroutine Call Slots</a></li>
<li class="level1"><a href="#RpcOutcomes">RPC Outcomes</a><ul><li class="level2"><a href="#ResultOutcomes">Result Outcomes</a></li>
<li class="level2"><a href="#ErrorOutcomes">Error Outcomes</a></li>
<li class="level2"><a href="#DeferredOutcomes">Deferred Outcomes</a></li>
</ul>
</li>
<li class="level1"><a href="#ScopedRegistrations">Scoped Registrations</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="CallSlots"></a>
Call Slots</h1>
<p>A <em>slot</em> is a <em>callable target</em> that is called in response to a <em>signal</em> (the signal being the call invocation in this case). The term <em>slot</em>, borrowed from <a href="http://doc.qt.io/qt-5/signalsandslots.html">Qt's signals and slots</a>, is used to distinguish a call handler from an asynchronous operation handler.</p>
<p>A <em>callable target</em> can be:</p><ul>
<li>a free function,</li>
<li>a bound member function (using <code>std::bind</code>),</li>
<li>a function object,</li>
<li>a lambda function, etc.</li>
</ul>
<p>A <em>call slot</em> represents an RPC handler that does not have any expectations on the invocation payload arguments. If necessary, the payload arguments must be checked during runtime, in the body of the call handler.</p>
<p><a class="el" href="classwamp_1_1_session.html#a04846bb5a40a74a0fe8cd37e3d0102c0" title="Registers a WAMP remote procedure call. ">wamp::Session::enroll</a> expects a call slot with the following signature:</p>
<div class="fragment"><div class="line"><a class="code" href="classwamp_1_1_outcome.html">wamp::Outcome</a> <span class="keyword">function</span>(<a class="code" href="classwamp_1_1_invocation.html">wamp::Invocation</a>)</div>
</div><!-- fragment --><p>where:</p><ul>
<li><a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a> contains a <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> or a <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> object to be sent back to the caller, and,</li>
<li><a class="el" href="classwamp_1_1_invocation.html" title="Contains payload arguments and other details related to a remote procedure call invocation. ">wamp::Invocation</a> is an object containing information and payload arguments related to the RPC invocation.</li>
</ul>
<p>The following table summarizes the different types of call slots that can be used with the library:</p>
<table class="doxtable">
<tr>
<th>Slot Type </th><th>Wrapper Function </th><th>Slot Signature  </th></tr>
<tr>
<td><a class="el" href="_registrations.html#BasicCallSlots">Basic Call Slot</a> </td><td><code>wamp::basicRpc&lt;TResult, TArgs...&gt;</code> </td><td><code>TResult function(TArgs...)</code> </td></tr>
<tr>
<td><a class="el" href="_registrations.html#BasicCoroutineCallSlots">Basic Coroutine Call Slot</a> </td><td><code>wamp::basicCoroRpc&lt;TResult, TArgs...&gt;</code> </td><td><code>TResult function(TArgs..., Yield)</code> </td></tr>
<tr>
<td><a class="el" href="_registrations.html#UnpackedCallSlots">Unpacked Call Slot</a> </td><td><code>wamp::unpackedRpc&lt;TArgs...&gt;</code> </td><td><code>Outcome function(Invocation, TArgs...)</code> </td></tr>
<tr>
<td><a class="el" href="_registrations.html#UnpackedCoroutineCallSlots">Unpacked Coroutine Call Slot</a> </td><td><code>wamp::unpackedCoroRpc&lt;TArgs...&gt;</code> </td><td><code>Outcome function(Invocation, TArgs..., Yield)</code> </td></tr>
</table>
<p>where <code>Yield</code> represents the type <code>boost::asio::yield_context</code>.</p>
<h1><a class="anchor" id="BasicCallSlots"></a>
Basic Call Slots</h1>
<p>A <em>basic call slot</em> represents an RPC handler that expects one or more payload arguments having specific, static types. The <a class="el" href="classwamp_1_1_basic_invocation_unpacker.html#a8f16c142e25ba052d930d360756c9263">wamp::basicRpc</a> function can be used when registering such call slots. It takes a basic call slot, and converts it into a regular call slot that can be passed to <a class="el" href="classwamp_1_1_session.html#a04846bb5a40a74a0fe8cd37e3d0102c0" title="Registers a WAMP remote procedure call. ">wamp::Session::enroll</a>.</p>
<p><code>wamp::basicRpc</code> expects a call slot with the following signature:</p>
<div class="fragment"><div class="line">TResult <span class="keyword">function</span>(TArgs...)</div>
</div><!-- fragment --><p> where</p><ul>
<li><code>TResult</code> is a static return type that will be automatically converted to a single <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> payload argument and then returned as a <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a>. This return type may be <code>void</code> if the RPC is not expected to return a value.</li>
<li><code>TArgs...</code> matches the template parameter pack that was passed to <code>wamp::basicRpc</code>.</li>
</ul>
<p>Examples of basic call slots are: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> setSpeed(<span class="keywordtype">float</span> speed) { ... }</div>
<div class="line"><span class="comment">// ^            ^</span></div>
<div class="line"><span class="comment">// TResult    TArgs</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> purchase(std::string item, <span class="keywordtype">int</span> cost, <span class="keywordtype">int</span> qty) { ... }</div>
<div class="line"><span class="comment">//^                  ^          ^         ^</span></div>
<div class="line"><span class="comment">// \                 \----------|---------/</span></div>
<div class="line"><span class="comment">// TResult                    TArgs</span></div>
</div><!-- fragment --><p>The above slots can be registered as follows: </p><div class="fragment"><div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;setSpeed&quot;</span>),</div>
<div class="line">                basicRpc&lt;void, float&gt;(&amp;setSpeed),</div>
<div class="line">                handler);</div>
<div class="line"></div>
<div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;purchase&quot;</span>),</div>
<div class="line">                basicRpc&lt;int, std::string, int, int&gt;(&amp;purchase),</div>
<div class="line">                handler);</div>
</div><!-- fragment --><p>where <code>handler</code> is the asynchronous handler (or coroutine yield context) for the <b>enroll operation itself</b>.</p>
<p>Whenever a <a class="el" href="classwamp_1_1_session.html" title="Asynchronous session API used by a client peer in WAMP applications. ">wamp::Session</a> dispatches an RPC invocation to the above slots, it automatically unpacks the invocation payload positional arguments, and passes them to the slot's argument list. If <code>Session</code> cannot convert the invocation payload arguments to their target types, it automatically sends an <code>ERROR</code> reply back to the router.</p>
<h1><a class="anchor" id="BasicCoroutineCallSlots"></a>
Basic Coroutine Call Slots</h1>
<p>A <em>basic coroutine call slot</em> is like a regular <em>basic call slot</em>, except that it is executed within the context of a coroutine. This is useful for RPC handlers that need to perform asynchronous operations themselves. The <a class="el" href="classwamp_1_1_basic_coro_invocation_unpacker.html#a4672d2cfc2538feb2f0027bf6618895f">wamp::basicCoroRpc</a> function can be used when registering such call slots. It takes a basic coroutine call slot, and converts it into a regular call slot that can be passed to <a class="el" href="classwamp_1_1_session.html#a04846bb5a40a74a0fe8cd37e3d0102c0" title="Registers a WAMP remote procedure call. ">wamp::Session::enroll</a>.</p>
<p><code>wamp::basicCoroRpc</code> expects a call slot with the following signature:</p>
<div class="fragment"><div class="line">TResult <span class="keyword">function</span>(TArgs..., boost::asio::yield_context)</div>
</div><!-- fragment --><p> where</p><ul>
<li><code>TResult</code> is a static return type that will be automatically converted to a single <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> payload argument and then returned as a <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a>. This return type may be <code>void</code> if the RPC is not expected to return a value.</li>
<li><code>TArgs...</code> matches the template parameter pack that was passed to <code>wamp::basicCoroRpc</code>.</li>
<li><code>boost::asio::yield_context</code> represents the RPC's coroutine context.</li>
</ul>
<p>Examples of basic coroutine call slots are: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Yield = boost::asio::yield_context;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> setSpeed(<span class="keywordtype">float</span> speed, Yield yield) { ... }</div>
<div class="line"><span class="comment">// ^            ^</span></div>
<div class="line"><span class="comment">// TResult    TArgs</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> purchase(std::string item, <span class="keywordtype">int</span> cost, <span class="keywordtype">int</span> qty, Yield yield) { ... }</div>
<div class="line"><span class="comment">//^                  ^          ^         ^</span></div>
<div class="line"><span class="comment">// \                 \----------|---------/</span></div>
<div class="line"><span class="comment">// TResult                    TArgs</span></div>
</div><!-- fragment --><p>The above slots can be registered as follows: </p><div class="fragment"><div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;setSpeed&quot;</span>),</div>
<div class="line">                basicCoroRpc&lt;void, float&gt;(&amp;setSpeed),</div>
<div class="line">                handler);</div>
<div class="line"></div>
<div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;purchase&quot;</span>),</div>
<div class="line">                basicCoroRpc&lt;int, std::string, int, int&gt;(&amp;purchase),</div>
<div class="line">                handler);</div>
</div><!-- fragment --><p>where <code>handler</code> is the asynchronous handler (or coroutine yield context) for the <b>enroll operation itself</b>.</p>
<p>Whenever a <a class="el" href="classwamp_1_1_session.html" title="Asynchronous session API used by a client peer in WAMP applications. ">wamp::Session</a> dispatches an RPC invocation to the above slots, it spawns a new coroutine to be executed on <a class="el" href="classwamp_1_1_session.html#a8a228862fc9d8d299a484642a4c57137" title="Obtains the IO service used to execute user-provided handlers. ">wamp::Session::userIosvc()</a>. It then automatically unpacks the invocation payload positional arguments, and passes them to the slot's argument list. If <code>Session</code> cannot convert the invocation payload arguments to their target types, it automatically sends an <code>ERROR</code> reply back to the router.</p>
<h1><a class="anchor" id="UnpackedCallSlots"></a>
Unpacked Call Slots</h1>
<p>An <em>unpacked call slot</em> represents an RPC handler that expects one or more payload arguments having specific, static types. The <a class="el" href="classwamp_1_1_invocation_unpacker.html#a3fae9c987f4fcc7bbd277f7f1fea3f26">wamp::unpackedRpc</a> function can be used when registering such call slots. It takes an unpacked call slot, and converts it into a regular call slot that can be passed to <a class="el" href="classwamp_1_1_session.html#a04846bb5a40a74a0fe8cd37e3d0102c0" title="Registers a WAMP remote procedure call. ">wamp::Session::enroll</a>.</p>
<p><code>wamp::unpackedRpc</code> expects a call slot with the following signature:</p>
<div class="fragment"><div class="line"><a class="code" href="classwamp_1_1_outcome.html">wamp::Outcome</a> <span class="keyword">function</span>(<a class="code" href="classwamp_1_1_invocation.html">wamp::Invocation</a>, TArgs...)</div>
</div><!-- fragment --><p> where</p><ul>
<li><a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a> contains a <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> or a <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> object to be sent back to the caller,</li>
<li><a class="el" href="classwamp_1_1_invocation.html" title="Contains payload arguments and other details related to a remote procedure call invocation. ">wamp::Invocation</a> is an object containing information and payload arguments related to the RPC invocation, and,</li>
<li><code>TArgs...</code> matches the template parameter pack that was passed to <code>wamp::unpackedRpc</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Unpacked call slots differ from basic call slots in the following ways:<ul>
<li>Unpacked call slots are passed a <a class="el" href="classwamp_1_1_invocation.html" title="Contains payload arguments and other details related to a remote procedure call invocation. ">wamp::Invocation</a> object, which contains metadata on the call invocation itself. It also allows the slot to manually send a <code>YIELD</code> message back to the caller in a separate asynchronous task.</li>
<li>Unpacked call slots are expected to return a <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a> object. This allows such slots to return Outcome::deferred(), which indicates to the library that the callee will manually send a <code>YIELD</code> message back to the caller.</li>
</ul>
</dd></dl>
<p>Examples of unpacked call slots are: </p><div class="fragment"><div class="line">Outcome setSpeed(Invocation inv, <span class="keywordtype">float</span> speed) { ... }</div>
<div class="line"><span class="comment">//                                 ^</span></div>
<div class="line"><span class="comment">//                               TArgs</span></div>
<div class="line"></div>
<div class="line">Outcome purchase(Invocation inv, std::string item, <span class="keywordtype">int</span> cost, <span class="keywordtype">int</span> qty) { ... }</div>
<div class="line"><span class="comment">//                                       ^          ^         ^</span></div>
<div class="line"><span class="comment">//                                       \----------|---------/</span></div>
<div class="line"><span class="comment">//                                                TArgs</span></div>
</div><!-- fragment --><p>The above slots can be registered as follows: </p><div class="fragment"><div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;setSpeed&quot;</span>),</div>
<div class="line">                unpackedRpc&lt;float&gt;(&amp;setSpeed),</div>
<div class="line">                handler);</div>
<div class="line"></div>
<div class="line">session-&gt;enroll(Procedure(<span class="stringliteral">&quot;purchase&quot;</span>),</div>
<div class="line">                unpackedRpc&lt;std::string, int, int&gt;(&amp;purchase),</div>
<div class="line">                handler);</div>
</div><!-- fragment --><p>where <code>handler</code> is the asynchronous handler (or coroutine yield context) for the <b>enroll operation itself</b>.</p>
<p>Whenever a <a class="el" href="classwamp_1_1_session.html" title="Asynchronous session API used by a client peer in WAMP applications. ">wamp::Session</a> dispatches an RPC invocation to the above slots, it automatically unpacks the invocation payload positional arguments, and passes them to the slot's argument list. If <code>Session</code> cannot convert the invocation payload arguments to their target types, it automatically sends an <code>ERROR</code> reply back to the router.</p>
<h1><a class="anchor" id="UnpackedCoroutineCallSlots"></a>
Unpacked Coroutine Call Slots</h1>
<p>An <em>unpacked coroutine call slot</em> is like an <a class="el" href="_registrations.html#UnpackedCallSlots">unpacked call slot</a>, except that the slot is executed within the context of a coroutine. The <a class="el" href="classwamp_1_1_coro_invocation_unpacker.html#a636defc9ed2d8c279f65c25aa121c37d">wamp::unpackedCoroRpc</a> function can be used when registering such call slots.</p>
<p><code>wamp::unpackedCoroRpc</code> expects a call slot with the following signature:</p>
<div class="fragment"><div class="line"><a class="code" href="classwamp_1_1_outcome.html">wamp::Outcome</a> <span class="keyword">function</span>(wamp::Invocation, TArgs..., boost::asio::yield_context)</div>
</div><!-- fragment --><p> where</p><ul>
<li><a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a> contains a <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> or a <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> object to be sent back to the caller,</li>
<li><a class="el" href="classwamp_1_1_invocation.html" title="Contains payload arguments and other details related to a remote procedure call invocation. ">wamp::Invocation</a> is an object containing information and payload arguments related to the RPC invocation, and,</li>
<li><code>TArgs...</code> matches the template parameter pack that was passed to <code>wamp::unpackedRpc</code>.</li>
<li><code>boost::asio::yield_context</code> represents the RPC's coroutine context.</li>
</ul>
<h1><a class="anchor" id="RpcOutcomes"></a>
RPC Outcomes</h1>
<p>RPC call slots are required to return a <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation. ">wamp::Outcome</a> object. <code>Outcome</code> is a discriminated union (i.e. variant) that can contain either:</p><ul>
<li>a <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> object, which contains positional/keyword return arguments,</li>
<li>a <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> object, which contains an error URI and other error-related information, or,</li>
<li>none of the above, which means that the outcome is <em>deferred</em>.</li>
</ul>
<h2><a class="anchor" id="ResultOutcomes"></a>
Result Outcomes</h2>
<p>An RPC call slot can send a result back to the caller by returning a <a class="el" href="classwamp_1_1_result.html" title="Contains a remote procedure result yielded by a callee or received by a caller. ">wamp::Result</a> object:</p>
<div class="fragment"><div class="line">Outcome add(Invocation, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> Result().withArgs(a + b);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If only positional <code>Variant</code> arguments need to be returned, they can be returned directly via a braced initializer list:</p>
<div class="fragment"><div class="line">Outcome add(Invocation, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> {a + b};</div>
<div class="line">}</div>
</div><!-- fragment --><p>If an empty result needs to be returned, an empty initializer list can be used:</p>
<div class="fragment"><div class="line">Outcome doSomething()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do something...</span></div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ErrorOutcomes"></a>
Error Outcomes</h2>
<p>An RPC call slot can send an error back to the caller by returning a <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> object:</p>
<div class="fragment"><div class="line">Outcome divide(Invocation, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (b == 0)</div>
<div class="line">        <span class="keywordflow">return</span> Error(<span class="stringliteral">&quot;myapp.divide_by_zero&quot;</span>);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> {a/b};</div>
<div class="line">}</div>
</div><!-- fragment --><p>Instead of returning an <code>Error</code> object via the <code>Outcome</code> return parameter, a call slot can also throw an <code>Error</code> object as an exception. The library will catch such exceptions and will send a corresponding <code>ERROR</code> message back to the caller:</p>
<div class="fragment"><div class="line">Outcome divide(Invocation, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (b == 0)</div>
<div class="line">        <span class="keywordflow">throw</span> Error(<span class="stringliteral">&quot;myapp.divide_by_zero&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> {a/b};</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Thrown exception types other than <a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages...">wamp::Error</a> are <em>not</em> handled by the library, and will result in the exception being rethrown by <code>boost::asio::io_service::run</code>.</dd></dl>
<h2><a class="anchor" id="DeferredOutcomes"></a>
Deferred Outcomes</h2>
<p>A <em>deferred</em> outcome means that the call slot does not return anything, and that measures will be taken by the callee to manually yield a <code>Result</code> or <code>Error</code> object back to the caller (via <a class="el" href="classwamp_1_1_invocation.html#a63fa8db1f88bd3181ff0d8c8f2f0e9fb" title="Manually sends a YIELD result back to the callee. ">wamp::Invocation::yield</a>). This can be useful when the call result can only be determined in a different asynchronous context.</p>
<p>Example: </p><div class="fragment"><div class="line">Outcome Client::addPerson(Invocation inv, <a class="code" href="namespacewamp.html#a0bc7bf8714c7de555c2fb308561b563d">Object</a> person)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We need to issue another RPC to the database service before we can</span></div>
<div class="line">    <span class="comment">// fulfill this RPC.</span></div>
<div class="line">    boost::asio::spawn(inv.iosvc(),</div>
<div class="line">        [<span class="keyword">this</span>, inv](boost::asio::yield_context yield)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> dbResult = session_-&gt;call( Rpc(<span class="stringliteral">&quot;db.add&quot;</span>).withArgs(person),</div>
<div class="line">                                            yield );</div>
<div class="line">            <span class="comment">// Manually send the result back to the caller</span></div>
<div class="line">            <span class="keyword">auto</span> personId = dbResult[0].to&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">            inv.yield({personId});</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We don&#39;t know the result yet as this point. Return a deferred outcome</span></div>
<div class="line">    <span class="comment">// to indicate that we&#39;ll send the result manually in a different</span></div>
<div class="line">    <span class="comment">// asynchronous context.</span></div>
<div class="line">    <span class="keywordflow">return</span> Outcome::deferred();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="ScopedRegistrations"></a>
Scoped Registrations</h1>
<p>A <a class="el" href="classwamp_1_1_scoped_registration.html" title="Limits a Registration&#39;s lifetime to a particular scope. ">wamp::ScopedRegistration</a> object can be used to limit a registration's lifetime to a particular scope. When a <code>ScopedRegistration</code> object is destroyed, it automatically unregisters the registration. This helps in automating the lifetime management of RPC registrations using RAII techniques.</p>
<p>Here's an example illustrating how <code>ScopedRegistration</code> can be used to manage the lifetime of a registration:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Delegate</div>
<div class="line">{</div>
<div class="line">    Outcome rpc(Invocation inv);</div>
<div class="line"></div>
<div class="line">    ScopedRegistration reg;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    boost::asio::io_service iosvc;</div>
<div class="line">    boost::asio::spawn(iosvc, [&amp;](boost::asio::yield_context yield)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> session = CoroSession&lt;&gt;::create(connectorList);</div>
<div class="line">        session-&gt;connect(yield);</div>
<div class="line">        session-&gt;join(<span class="stringliteral">&quot;somerealm&quot;</span>, yield);</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> std::placeholders;</div>
<div class="line">            Delegate delegate;</div>
<div class="line">            delegate.reg = session-&gt;enroll(</div>
<div class="line">                            Procedure(<span class="stringliteral">&quot;someprocedure&quot;</span>),</div>
<div class="line">                            std::bind(&amp;Delegate::rpc, delegate, _1),</div>
<div class="line">                            yield);</div>
<div class="line"></div>
<div class="line">        }  <span class="comment">// When the &#39;delegate&#39; object leaves this scope, its</span></div>
<div class="line">           <span class="comment">// ScopedRegisration member gets destroyed. This will</span></div>
<div class="line">           <span class="comment">// automatically unregister the regisration, thereby avoiding</span></div>
<div class="line">           <span class="comment">// further member function calls on the deleted &#39;delegate&#39; object.</span></div>
<div class="line">    });</div>
<div class="line">    iosvc.run();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 23 2015 14:08:52 for CppWAMP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
