/*------------------------------------------------------------------------------
                Copyright Butterfly Energy Systems 2014-2015.
           Distributed under the Boost Software License, Version 1.0.
              (See accompanying file LICENSE_1_0.txt or copy at
                    http://www.boost.org/LICENSE_1_0.txt)
------------------------------------------------------------------------------*/

//------------------------------------------------------------------------------
/** @page Concepts Concepts
Describes restrictions on types used by generic facilities.
Concepts:
- @subpage EventSlot
- @subpage CallSlot
- @subpage VisitorConcept
- @subpage Serializer
- @subpage TransportBuffer
- @subpage Transport
- @subpage Establisher
*/

//------------------------------------------------------------------------------
/** @page EventSlot EventSlot
`EventSlot` is the C++ concept for callable target that is invoked when a
matching pub/sub event if received.
An `EventSlot` must conform to one of the following:
- @ref StaticEventSlot
- @ref DynamicEventSlot
- @ref VoidEventSlot

A _slot_ is a function that is called in response to a _signal_ (the signal
being the event topic in this case). The term _slot_, borrowed from
[Qt's signals and slots][qt_sig], is used to distinguish these handlers from
asynchronous operation handlers.

Every `EventSlot` must accept a wamp::PublicationId as its first parameter.
This publication ID is an ephemeral integer generated by the _Broker_.

[qt_sig]: http://doc.qt.io/qt-5/signalsandslots.html


@section StaticEventSlot StaticEventSlot

A `StaticEventSlot` is an @ref EventSlot that accepts a fixed number of
statically-typed arguments.
A `StaticEventSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::PublicationId, TParams...)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where:
- wamp::PublicationId is an ephemeral ID associated with an event publication
- _TParams..._ is the list of static types passed to the `TParams`
  template parameter of wamp::Client::subscribe.
- Each type in the _TParams..._ type list must be a destination type that a
  wamp::Variant can convert to.


@section DynamicEventSlot DynamicEventSlot

A `DynamicEventSlot` is an @ref EventSlot that accepts dynamically typed
arguments.
A `DynamicEventSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::PublicationId, wamp::Args)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where:
- wamp::PublicationId is an ephemeral ID associated with an event publication
- wamp::Args is a bundle of positional and/or keyword arguments, stored as
  wamp::Variant objects.


@section VoidEventSlot VoidEventSlot

A `VoidEventSlot` is an @ref EventSlot that takes no arguments other than
the `PublicationId`.
A `VoidEventSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::PublicationId)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where wamp::PublicationId is an ephemeral ID associated with an event
publication.
*/

//------------------------------------------------------------------------------
/** @page CallSlot CallSlot
`CallSlot` is the C++ concept for a callable target that is invoked when a
matching RPC invocation if received.
A `CallSlot` must conform to one of the following:
- @ref StaticCallSlot
- @ref DynamicCallSlot
- @ref VoidCallSlot

A _slot_ is a function that is called in response to a _signal_ (the signal
being the procedure call in this case). The term _slot_, borrowed from
[Qt's signals and slots][qt_sig], is used to distinguish these handlers from
asynchronous operation handlers.

Every `CallSlot` must accept a wamp::Invocation object as its first parameter.
This object provides the means for returning a `YIELD` or `ERROR` result back
to the peer that originated the RPC.

[qt_sig]: http://doc.qt.io/qt-5/signalsandslots.html


@section StaticCallSlot StaticCallSlot

A `StaticCallSlot` is a @ref CallSlot that accepts a fixed number of
statically-typed arguments.
A `StaticCallSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::Invocation, TParams...)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where:
- wamp::Invocation is an object that provides the means for returning a `YIELD`
  or `ERROR` result.
- _TParams..._ is the list of static types passed to the `TParams`
  template parameter of wamp::Client::enroll.
- Each type in the _TParams..._ type list must be a destination type that a
  wamp::Variant can convert to.


@section DynamicCallSlot DynamicCallSlot

A `DynamicCallSlot` is an @ref CallSlot that accepts dynamically typed
arguments.
A `DynamicCallSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::Invocation, wamp::Args)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where:
- wamp::Invocation is an object that provides the means for returning a `YIELD`
  or `ERROR` result.
- wamp::Args is a bundle of positional and/or keyword arguments, stored as
  wamp::Variant objects.


@section VoidCallSlot VoidCallSlot

A `VoidCallSlot` is an @ref CallSlot that takes no arguments other than
the `Invocation` object.
A `VoidCallSlot` is any callable target that can be assigned to:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::function<void (wamp::Invocation)>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
where wamp::Invocation is an object that provides the means for returning a
`YIELD` or `ERROR` result.
*/

//------------------------------------------------------------------------------
/** @page VisitorConcept Visitors

Concepts:
- @ref StaticVisitor
- @ref BinaryVisitor
- @ref OperandVisitor

@section StaticVisitor StaticVisitor

`StaticVisitor` is the C++ concept for a function object having `operator()`
overloads that can take any of wamp::Variant's bound types as a parameter.

Given:
- `visitor`: a `StaticVisitor` instance, and,
- `bound`: a reference to _any_ of wamp::Variant's bound types
   (`Null`, `Bool`, `Int`, `UInt`, `Real`, `String`, `Array`, or `Object`),

then the following expressions must be valid:

Expression                         | Effect
---------------------------------- | ------
`decltype(visitor)`\::`ResultType` | Yields the common type returned by all `operator()` overloads
`visitor(bound)`                   | Returns a value of type `decltype(visitor)`\::`ResultType`

@section BinaryVisitor BinaryVisitor
`BinaryVisitor` is the C++ concept for a function object having `operator()`
overloads that take two arguments of wamp::Variant's bound types. The overloads
must handle _every_ combination of Variant's bound types. To avoid
combinatorial explosion, the `operator()` overloads are typically template
functions that perform compile-time pattern matching, using type traits and
SFINAE.

Given:
- `visitor`: a `BinaryVisitor` instance, and,
- `left` and `right`: two wamp::Variant bound type references,

then the following expressions must be valid:

Expression                         | Effect
---------------------------------- | ------
`decltype(visitor)`\::`ResultType` | Yields the common type returned by all `operator()` overloads
`vis(left, right)`                 | Returns a value of type `decltype(visitor)`\::`ResultType`

where `left` and `right` are references to _any_ of `Variant`'s bound types
(`Null`, `Bool`, `Int`, `UInt`, `Real`, `String`, `Array`, or `Object`).

@section OperandVisitor OperandVisitor
`OperandVisitor` is the C++ concept for a function object having `operator()`
overloads that take two arguments.
This concept is required for the @ref applyWithOperand function. The
operator() overloads must handle _any_ of wamp::Variant's bound types as their
first argument. They must also handle a value or reference of type `O` for
their second argument, where `O` is the type of the `operand` argument passed
to `applyWithOperand`.

Given:
- `visitor`: an `OperandVisitor` instance,
- `bound`: a reference to _any_ of wamp::Variant's bound types, and,
   (`Null`, `Bool`, `Int`, `UInt`, `Real`, `String`, `Array`, or `Object`)
- `operand`: an operand l-value or r-value reference,

then the following expressions must be valid:

Expression                         | Effect
---------------------------------- | ------
`decltype(visitor)`\::`ResultType` | Yields the common type returned by all `operator()` overloads
`visitor(bound, operand)`          | Returns a value of type `decltype(visitor)`\::`ResultType`
*/

//------------------------------------------------------------------------------
/** @page Serializer Serializer
A `Serializer` is a specialization of the wamp::Codec template class, where the
following expressions must be valid:

Expression                                  | Effect
------------------------------------------- | ------
`Serializer::decodeBuffer(buffer, variant)` | Deserializes from a @ref TransportBuffer to a wamp::Variant.
`Serializer::encodeBuffer(variant, buffer)` | Serializes from wamp::Variant to a @ref TransportBuffer.

where @ref TransportBuffer is the C++ concept for buffers used by the transport layer.

`Serializer::decodeBuffer` is expected to throw a
@ref wamp::error::Decode exception if it fails to deserialize the buffer.

The following classes meet the requirements of `Serializer`:
- wamp::Codec<CodeId::json> (aka wamp::Json)
- wamp::Codec<CodeId::msgpack> (aka wamp::Msgpack)

*/

//------------------------------------------------------------------------------
/** @page TransportBuffer TransportBuffer
A `TransportBuffer` holds a WAMP message in the format used for transmission
over the transport connection. A `TransportBuffer` must meet the following
requirements:

Given
- `buffer`: a `TransportBuffer` instance
- `d`: a `const char*` pointing to the first element of an array of bytes
- `n`: the number of bytes in the array pointed to by `d`

then the following expressions must be valid:

Expression           | Effect
-------------------- | ------
`buffer.length()`    | Returns the current length, in bytes, of the message data.
`buffer.data()`      | Returns a `const char*` pointing to the first message data byte.
`buffer.write(d, n)` | Appends `n` bytes from `d` to the buffer's message data.

The following classes meet the requirements of `Serializer`:
- `wamp::internal::AsioBuffer`

@see @ref Transport
*/

//------------------------------------------------------------------------------
/** @page Transport Transport
A `Transport` is used to transmit WAMP messages between peers. It must provide
the following minimal generic interface:

~~~~~~~~
class MeetsTransport
{
public:
    // Shared pointer to a type meeting the TransportBuffer concept
    using Buffer = std::shared_ptr<MeetsTransportBuffer>;

    // Handler type called when a WAMP message is received
    using RxHandler = std::function<void (Buffer)>;

    // Handler type called when a transport error occurs
    using FailHandler = std::function<void (std::error_code ec)>;

    // Returns the maximum length of a message that can be transmitted.
    size_t maxSendLength() const;

    // Returns `true` if the transport has been started.
    bool isStarted() const;

    // Enables the receiving of messages on the transport.
    void start(RxHandler rxHandler, FailHandler failHandler);

    // Obtains a buffer to be used for filling in and sending messages.
    Buffer getBuffer();

    // Enqueues the given message for transmission.
    void send(Buffer message);

    // Closes the transport connection, aborting all pending send/receive
    // operations.
    void close();

    // Posts the given handler to the transport's I/O service.
    template <typename TFunctor>
    void post(TFunctor&& fn);
~~~~~~~~

The following classes meet the requirements of `Transport`:
- `wamp::internal::AsioTransport`

@see @ref TransportBuffer
*/

//------------------------------------------------------------------------------
/** @page Establisher Establisher
An `Establisher` is used by `internal::AsioEndpoint` to create and connect a
Boost.Asio socket.

Given
- `est`: an `Establisher` instance
- `handler`: a callable entity with the signature:

~~~
void (boost::system::error_code, Establisher::SocketPtr&&)
~~~

then:
- `Establisher` must be move-constrictible, and,
- the following expressions must be valid:

Expression               | Effect
------------------------ | ------
`Establisher::Socket`    | Yields the type of socket that the Establisher creates and connects.
`Establisher::SocketPtr` | Yields a shared pointer to an Establisher::Socket.
`est.establish(handler)` | Establishes the socket connection, then calls `handler`.
`est.cancel()`           | Cancels an `establish` operation in progress.

If an `establish` operation is cancelled, it shall return, via the completion
handler,  an error code equivalent to `boost::system::errc::operation_canceled`.

The following classes meet the requirements of `Establisher`:
- `wamp::internal::TcpAcceptor`
- `wamp::internal::TcpOpener`
- `wamp::internal::UdsAcceptor`
- `wamp::internal::UdsOpener`
*/
